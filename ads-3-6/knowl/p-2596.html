<!DOCTYPE html>
<html lang="en-US">
<!--**************************************-->
<!--*    Generated from PreTeXt source   *-->
<!--*    on 2019-05-14T09:26:00-04:00    *-->
<!--*                                    *-->
<!--*      https://pretextbook.org       *-->
<!--*                                    *-->
<!--**************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body>
<h6 class="heading"><span class="type">Paragraph</span></h6>
<ol class="lower-alpha">
<li><p>The terms of \(A\) in <a data-knowl="./knowl/ex-three-sequences.html" title="Example 8.2.2: Three sequences defined in different ways">ExampleÂ 8.2.2</a> are very easy to compute because of the closed form expression. No matter what term you decide to compute, only three operations need to be performed.</p></li>
<li>
<p>How to compute the terms of \(B\) is not so clear. Suppose that you wanted to know \(B(100)\text{.}\) One approach would be to apply the definition recursively:</p>
<div class="displaymath">
\begin{equation*}
B(100) = B(99) + 3 = (B(98) + 3) + 3 =\cdots
\end{equation*}
</div>
<p>The recursion equation for \(B\) would be applied 100 times and 100 additions would then follow. To compute \(B(k)\) by this method, \(2k\) operations are needed. An iterative computation of \(B(k)\) is an improvement: \(B(1) =B(0) +3 = 2 + 3 = 5\\
\\
B(2) =B(1)+3= 5 + 3 = 8\\
\\
\text{etc}.\) Only \(k\) additions are needed. This still isn't a good situation. As \(k\) gets large, we take more and more time to compute \(B(k)\text{.}\)  The formula \(B(k)=B(k-1)+3\) is called a recurrence relation on \(B\text{.}\) The process of finding a closed form expression for \(B(k)\text{,}\) one that requires no more than some fixed number of operations, is called solving the recurrence relation.</p>
</li>
<li><p>The determination of \(C_k\) is a standard kind of problem in combinatorics. One solution is by way of a recurrence relation. In fact, many problems in combinatorics are most easily solved by first searching for a recurrence relation and then solving it. The following observation will suggest the recurrence relation that we need to determine \(C_k\text{.}\) If \(k \geq  2\text{,}\) then every string of 0's and 1's with length \(k\) and no two consecutive 0's is either \(1s_{k-1}\) or \(01s_{k-2}\text{,}\) where \(s_{k-1}\) and \(s_{k-2}\) are strings with no two consecutive 0's of length \(k - 1\) and \(k - 2\) respectively. From this observation we can see that \(C_k= C_{k-2}+C_{k-1}\) for \(k\geq 2\text{.}\) The terms \(C_0=
1\) and \(C_1 = 2\) are easy to determine by enumeration. Now, by iteration, any \(C_k\) can be easily determined. For example, \(C_5 = 21\) can be computed with five additions. A closed form expression for \(C_k\) would be an improvement. Note that the recurrence relation for \(C_k\) is identical to the one for <a data-knowl="./knowl/ex-fibonacci-sequence.html" title="Example 8.1.8: The Fibonacci Sequence">The Fibonacci Sequence</a>. Only the basis is different.</p></li>
</ol>
<span class="incontext"><a href="s-Sequences.html#p-2596">in-context</a></span>
</body>
</html>
