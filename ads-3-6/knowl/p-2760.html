<!DOCTYPE html>
<html lang="en-US">
<!--**************************************-->
<!--*    Generated from PreTeXt source   *-->
<!--*    on 2019-05-14T09:26:03-04:00    *-->
<!--*                                    *-->
<!--*      https://pretextbook.org       *-->
<!--*                                    *-->
<!--**************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body>
<h6 class="heading"><span class="type">Paragraph</span></h6>
<p>In the worst case, the algorithm must be executed with a list that is roughly half as large as in the previous execution. If we assume that Step 1 takes one time unit and \(T(n)\) is the worst-case time for a list of \(n\) items, then</p>
<div class="displaymath">
\begin{gather}
T(n)= 1 + T (\lfloor n/2 \rfloor ),  \quad n&gt;0\tag{8.4.1}
\end{gather}
</div>
<p>For simplicity, we will assume that</p>
<div class="displaymath">
\begin{gather}
T(0) = 0\tag{8.4.2}
\end{gather}
</div>
<p>even though the conditions of Step 1 must be evaluated as false if \(n = 0\text{.}\) You might wonder why \(n/2\) is truncated in <a data-knowl="./knowl/eq-bin-search-recursion.html" title="Equation 8.4.1">(8.4.1)</a>. If \(n\) is odd, then \(n = 2 k + 1\) for some \(k\geq  0\text{,}\) the middle of the list will be the \((k + 1)^{st}\)  item, and no matter what half of the list the search is directed to, the reduced list will have \(k = \lfloor n/2\rfloor\) items. On the other hand, if \(n\) is even, then \(n
= 2 k\) for \(k&gt;0\text{.}\) The middle of the list will be the \(k^{th}\) item, and the worst case will occur if we are directed to the \(k\) items that come after the middle (the \((k + 1)^{st}\) through \((2k)^{th}\) items). Again the reduced list has \(\lfloor n/2 \rfloor\) items.</p>
<span class="incontext"><a href="s-some-common-rrs.html#p-2760">in-context</a></span>
</body>
</html>
