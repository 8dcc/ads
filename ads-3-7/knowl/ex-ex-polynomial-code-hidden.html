<!DOCTYPE html>
<html lang="en-US">
<!--**************************************-->
<!--*    Generated from PreTeXt source   *-->
<!--*    on 2020-01-01T10:19:21-05:00    *-->
<!--*                                    *-->
<!--*      https://pretextbook.org       *-->
<!--*                                    *-->
<!--**************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body><article class="example example-like"><p>An important observation regarding the previous example is that the nonzero elements of \(GF(4)\) can be represented two ways.  First as a linear combination of 1 and \(a\text{.}\)   There are four such linear combinations, one of which is zero.  Second, as powers of \(a\text{.}\)  There are three distinct powers and the each match up with a nonzero linear combination:</p>
<div class="displaymath">
\begin{equation*}
\begin{array}{c}
a^0 = 1\cdot 1 + 0 \cdot a\\
a^1 = 0\cdot 1 + 1 \cdot a\\
a^2 = 1\cdot 1 + 1 \cdot a\\
\end{array}
\end{equation*}
</div>
<p>Next, we briefly describe the field \(GF(8)\) and how an error correcting code can be build on a the same observation about that field.</p>
<p>First, we start with the irreducible polynomial \(p(x)=x^3 + x + 1\) over \(\mathbb{Z}_2\text{.}\) There is another such cubic polynomial, but its choice produces essentially the same result.    Just as we did in the previous example, we assume we have a zero of \(p(x)\) and call it  \(\beta\text{.}\)  Since we have assumed that \(p(\beta)= \beta^3+\beta + 1=0\text{,}\) we get the recurrence relation for powers \(\beta^3=\beta + 1\) that lets us reduce the seven powers \(\beta^k\text{,}\) \(0 \leq k \leq 6\text{,}\) to  linear combinations of 1, \(\beta\text{,}\) and \(\beta^2\text{.}\) Higher powers will reduce to these seven, which make up the elements of a field with \(2^3=8\) elements when we add zero to the set.   We leave as an exercise for you to set up a table relating powers of \(\beta\) with the linear combinations.</p>
<p>With this information we are now in a position to take blocks of four bits and encode them with three parity bits to create an error correcting code.   If the bits are \(b_3b_4b_5b_6\text{,}\) then we reduce the expression \(B_m= b_3\cdot \beta^3 +b_4\cdot \beta^4 +b_5\cdot \beta^5 +b_6\cdot \beta^6\) using the recurrence relation to an expression \(B_p=b_0\cdot 1 +b_1\cdot \beta +b_2\cdot \beta^2\text{.}\)   Since we are equating equals within \(GF(8)\text{,}\) we have \(B_p=B_m\text{,}\) or \(B_p+B_m=0\text{.}\)  The encoded message is \(b_0b_1b_2b_3b_4b_5b_6\text{,}\) which is a representation of 0 in \(GF(8)\text{.}\)  If the transmitted sequence of bits is received as \(c_0c_1c_2c_3c_4c_5c_6\) we reduce \(C=c_0\cdot 1 +c_1\cdot \beta +c_2\cdot \beta^2 +c_3\cdot \beta^3 +c_4\cdot \beta^4 +c_5\cdot \beta^5 +c_6\cdot \beta^6\) using the recurrence.   If there was no transmission error, the result is zero.  If the reduced result is zero it is most likely that the original message was \(c_3c_4c_5c_6\text{.}\)  If  bit \(k\) is switched in the transmission, then</p>
<div class="displaymath">
\begin{equation*}
C = B_p+B_m+ \beta^k= \beta^k
\end{equation*}
</div>
<p>Therefore if we reduce \(C\) with the recurrence, we get the linear combination of  1, \(\beta\text{,}\) and \(\beta^2\) that is equal to \(\beta^k\) and so we can identify the location of the error and correct it.</p></article></body>
</html>
